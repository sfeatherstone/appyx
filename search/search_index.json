{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Appyx \u00b6 A navigation framework built on top of Jetpack Compose https://github.com/bumble-tech/appyx Navigation for your Compose app on steroids \u00b6 Navigate directly from code \u2013 In a type-safe way, without boilerplate Gain control of navigation state \u2013 Making your navigation unit-testable Complete control over operations and behaviour \u2013 Use and extend the back stack or the view pager from the library, or build your own Use any animation for transitions \u2013 Anything you can represent with Compose Modifiers A different paradigm with superpowers \u00b6 Using Appyx you gain navigation superpowers in addition to screen-to-screen navigation: Break down screen boundaries \u2013 Using Routing sources you can navigate inside the screen as well as between them Make your navigation composable \u2013 Navigate whole scopes of your application Routing sources are versatile tools you can use for screen-to-screen as well as in-screen navigation: back stacks, card stacks, view pagers are just the beginning: You can create custom navigable components in no time: With Appyx you can break down screen boundaries and transform the screen itself: Launch the demo app \u00b6 Check out the project and launch the :app module for a quick demonstration Download \u00b6 See the Downloads page .","title":"Overview"},{"location":"#appyx","text":"A navigation framework built on top of Jetpack Compose https://github.com/bumble-tech/appyx","title":"Appyx"},{"location":"#navigation-for-your-compose-app-on-steroids","text":"Navigate directly from code \u2013 In a type-safe way, without boilerplate Gain control of navigation state \u2013 Making your navigation unit-testable Complete control over operations and behaviour \u2013 Use and extend the back stack or the view pager from the library, or build your own Use any animation for transitions \u2013 Anything you can represent with Compose Modifiers","title":"Navigation for your Compose app on steroids"},{"location":"#a-different-paradigm-with-superpowers","text":"Using Appyx you gain navigation superpowers in addition to screen-to-screen navigation: Break down screen boundaries \u2013 Using Routing sources you can navigate inside the screen as well as between them Make your navigation composable \u2013 Navigate whole scopes of your application Routing sources are versatile tools you can use for screen-to-screen as well as in-screen navigation: back stacks, card stacks, view pagers are just the beginning: You can create custom navigable components in no time: With Appyx you can break down screen boundaries and transform the screen itself:","title":"A different paradigm with superpowers"},{"location":"#launch-the-demo-app","text":"Check out the project and launch the :app module for a quick demonstration","title":"Launch the demo app"},{"location":"#download","text":"See the Downloads page .","title":"Download"},{"location":"basics/nodes-and-routing/","text":"Nodes and routing \u00b6 Nodes are the main structural element of an Appyx tree. Routing is how we add dynamism to that tree. Overview \u00b6 You can think of a Node as a standalone component with: Their own simplified lifecycle State restoration A @Composable view Business logic that's kept alive even when the view isn't added to the composition The ability to host generic Plugins to extract extra concerns without enforcing any particular architectural pattern Node illustration \u00b6 In many of the examples you'll see this panel as an illustration of a very simple Node \u2013 it has some local state (id, colour, and a counter). If you launch :app you can also change its state (colour) by tapping it. Its counter is stepped automatically. All of its state is persisted and restored. Parent nodes, child nodes \u00b6 Nodes are composable, as ParentNodes can have other Nodes as children. This means you can represent your whole application as a tree of Appyx nodes. You can go as granular or as high-level as it fits you. This allows to keep the complexity low in individual Nodes by extracting responsibilities to children, as well as composing other components to build more complex functionality. Dynamism by routing \u00b6 Having a static composition of Nodes isn't very exciting. You can add dynamism to the tree by changing the control flow via routing: A routing is a relation of a parent Node to a child Node The sum total of those relations in the app defines what part of the application the user sees A routing change will look and feel like navigation to the user of the app Routing sources \u00b6 All ParentNodes have the option to achieve this dynamism by utilising Routing sources such as the back stack. Using them you can: Add or remove child Nodes of a ParentNode Move them on and off the screen Change their states Here: Back stack illustrates adding and removing child Nodes Tiles illustrates changing the state of children and removing them from the ParentNode These are just two examples, you're of course not limited to using them. Lifecycle \u00b6 Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle . Read more in Lifecycle Summary \u00b6 A summary of Appyx's approach to apps: Compose your app out of components with their own lifecycles and state Navigation is local, broken down to individual pieces of routing Navigation is business-logic driven Navigation is stateful Navigation is unit-testable You're free to implement your own navigation engines by utilising routing sources Avoid global navigation concerns, like shared modules needing to know about the application, or the application needing to know about all its possible modules","title":"Nodes and routing"},{"location":"basics/nodes-and-routing/#nodes-and-routing","text":"Nodes are the main structural element of an Appyx tree. Routing is how we add dynamism to that tree.","title":"Nodes and routing"},{"location":"basics/nodes-and-routing/#overview","text":"You can think of a Node as a standalone component with: Their own simplified lifecycle State restoration A @Composable view Business logic that's kept alive even when the view isn't added to the composition The ability to host generic Plugins to extract extra concerns without enforcing any particular architectural pattern","title":"Overview"},{"location":"basics/nodes-and-routing/#node-illustration","text":"In many of the examples you'll see this panel as an illustration of a very simple Node \u2013 it has some local state (id, colour, and a counter). If you launch :app you can also change its state (colour) by tapping it. Its counter is stepped automatically. All of its state is persisted and restored.","title":"Node illustration"},{"location":"basics/nodes-and-routing/#parent-nodes-child-nodes","text":"Nodes are composable, as ParentNodes can have other Nodes as children. This means you can represent your whole application as a tree of Appyx nodes. You can go as granular or as high-level as it fits you. This allows to keep the complexity low in individual Nodes by extracting responsibilities to children, as well as composing other components to build more complex functionality.","title":"Parent nodes, child nodes"},{"location":"basics/nodes-and-routing/#dynamism-by-routing","text":"Having a static composition of Nodes isn't very exciting. You can add dynamism to the tree by changing the control flow via routing: A routing is a relation of a parent Node to a child Node The sum total of those relations in the app defines what part of the application the user sees A routing change will look and feel like navigation to the user of the app","title":"Dynamism by routing"},{"location":"basics/nodes-and-routing/#routing-sources","text":"All ParentNodes have the option to achieve this dynamism by utilising Routing sources such as the back stack. Using them you can: Add or remove child Nodes of a ParentNode Move them on and off the screen Change their states Here: Back stack illustrates adding and removing child Nodes Tiles illustrates changing the state of children and removing them from the ParentNode These are just two examples, you're of course not limited to using them.","title":"Routing sources"},{"location":"basics/nodes-and-routing/#lifecycle","text":"Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle . Read more in Lifecycle","title":"Lifecycle"},{"location":"basics/nodes-and-routing/#summary","text":"A summary of Appyx's approach to apps: Compose your app out of components with their own lifecycles and state Navigation is local, broken down to individual pieces of routing Navigation is business-logic driven Navigation is stateful Navigation is unit-testable You're free to implement your own navigation engines by utilising routing sources Avoid global navigation concerns, like shared modules needing to know about the application, or the application needing to know about all its possible modules","title":"Summary"},{"location":"how-to-use-appyx/codelabs/","text":"Appyx codelabs \u00b6 Coming soon! \u00b6 ETA week of 15 Aug","title":"Codelabs"},{"location":"how-to-use-appyx/codelabs/#appyx-codelabs","text":"","title":"Appyx codelabs"},{"location":"how-to-use-appyx/codelabs/#coming-soon","text":"ETA week of 15 Aug","title":"Coming soon!"},{"location":"how-to-use-appyx/quick-start/","text":"Quick start guide \u00b6 Suggestions \u00b6 Check out the project and launch the :app module for a quick demonstration Check out Nodes and routing , which explains the concepts you'll encounter in this guide. 1. Add Appyx to your project \u00b6 2. Create a root Node \u00b6 class RootNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"Hello world!\" ) } } Since this is the root of your tree, you'll also need to plug it in to your Activity, so that system events (Android lifecycle, back press, etc.) reach your components in the tree. class MainActivity : NodeActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { AppTheme { NodeHost ( integrationPoint = integrationPoint ) { RootNode ( buildContext = it ) } } } } } You only need to do this for the root of the tree. 3. Define children \u00b6 A single leaf node isn't all that interesting. Let's add some children to the root! First, let's define the possible set of children using a sealed class. We'll refer them via these routings: /** * You can create this class inside the body of RootNode * * Note: You must apply the 'kotlin-parcelize' plugin to use @Parcelize * https://developer.android.com/kotlin/parcelize */ sealed class Routing : Parcelable { @Parcelize object Child1 : Routing () @Parcelize object Child2 : Routing () @Parcelize object Child3 : Routing () } Next, let's modify RootNode so it extends ParentNode : class RootNode ( buildContext : BuildContext ) : ParentNode < Routing > ( routingSource = TODO ( \"We will come back to this in Step 4\" ), buildContext = buildContext ) { ParentNode expects us to implement the abstract method resolve . This is how we relate routings to actual children. Let's use these helper methods to define some placeholders for the time being \u2013 we'll soon make them more appealing: override fun resolve ( routing : Routing , buildContext : BuildContext ): Node = when ( routing ) { Routing . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } Routing . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } Routing . Child3 -> node ( buildContext ) { Text ( text = \"Placeholder for child 3\" ) } } Great! With this mapping created, we can now just refer to children using the sealed class elements, and Appyx will be able to relate them to other nodes. 4. Add a back stack \u00b6 The project wouldn't compile just yet. ParentNode expects us to pass an instance of a RoutingSource \u2013 the main control structure in any case when we want to add children. No need to worry now \u2013 for simplicity, let's just go with a simple BackStack implementation here: class RootNode ( buildContext : BuildContext , private val backStack : BackStack < Routing > = BackStack ( initialElement = Routing . Child1 , savedStateMap = buildContext . savedStateMap , ) ) : ParentNode < Routing > ( routingSource = backStack , // pass it here buildContext = buildContext ) { With this simple addition we've immediately gained a lot of power! Now we can use the back stack's API to add, replace, pop children with operations like: backStack . push ( Routing . Child2 ) // will add a new routing to the end of the stack and make it active backStack . replace ( Routing . Child3 ) // will replace the currently active child backStack . pop () // will remove the currently active child and restore the one before it Since we passed the back stack to the ParentNode , all such changes will be immediately reflected. We only need to add it to the composition: @Composable override fun View ( modifier : Modifier ) { Column { Text ( \"Hello world!\" ) // Let's add the children to the composition Children ( routingSource = backStack ) // Let's also add some controls so we can test it Row { TextButton ( onClick = { backStack . push ( Routing . Child1 ) }) { Text ( text = \"Push child 1\" ) } TextButton ( onClick = { backStack . push ( Routing . Child2 ) }) { Text ( text = \"Push child 2\" ) } TextButton ( onClick = { backStack . push ( Routing . Child3 ) }) { Text ( text = \"Push child 3\" ) } TextButton ( onClick = { backStack . pop () }) { Text ( text = \"Pop\" ) } } } } 5. Add transitions \u00b6 Adding some transitions is a one-liner: Children ( routingSource = backStack , transitionHandler = rememberBackstackSlider () ) You can also use a fader instead: rememberBackstackFader() , and you can supply a transition spec in both cases: rememberBackStackSlider { spring(stiffness = Spring.StiffnessLow) } Need something more custom? Instead of a back stack, you can find other routing sources in the library, or you can implement your own Instead of the default transition handlers, you can also use Jetpack Compose provided ones, or supply your own You can also read the Back stack documentation for more info on the specific options for the back stack. 6. Proper child nodes \u00b6 As a last step, let's replace at least one of the child placeholders with another proper node. Let's create a dedicated class: class SomeChildNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"This is SomeChildNode\" ) } } Now we can update the resolve method in RootNode so that the routing Child3 refers to this node. It should work out of the box: override fun resolve ( routing : Routing , buildContext : BuildContext ): Node = when ( routing ) { Routing . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } Routing . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } Routing . Child3 -> SomeChildNode ( buildContext ) } What's next? \u00b6 Congrats, you've just built your first Appyx tree! You can repeat the same pattern and make any embedded children also a ParentNode with their own children, routing sources, and transitions. As complexity grows, generally you would: Have a Node At some point make it a ParentNode and add children to it At some point extract the increasing complexity from a placeholder to another Node Repeat the same on children, go to 1. You can (and probably should) also extract local business logic, the view, any any other components into separate classes and plugins .","title":"Quick start guide"},{"location":"how-to-use-appyx/quick-start/#quick-start-guide","text":"","title":"Quick start guide"},{"location":"how-to-use-appyx/quick-start/#suggestions","text":"Check out the project and launch the :app module for a quick demonstration Check out Nodes and routing , which explains the concepts you'll encounter in this guide.","title":"Suggestions"},{"location":"how-to-use-appyx/quick-start/#1-add-appyx-to-your-project","text":"","title":"1. Add Appyx to your project"},{"location":"how-to-use-appyx/quick-start/#2-create-a-root-node","text":"class RootNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"Hello world!\" ) } } Since this is the root of your tree, you'll also need to plug it in to your Activity, so that system events (Android lifecycle, back press, etc.) reach your components in the tree. class MainActivity : NodeActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { AppTheme { NodeHost ( integrationPoint = integrationPoint ) { RootNode ( buildContext = it ) } } } } } You only need to do this for the root of the tree.","title":"2. Create a root Node"},{"location":"how-to-use-appyx/quick-start/#3-define-children","text":"A single leaf node isn't all that interesting. Let's add some children to the root! First, let's define the possible set of children using a sealed class. We'll refer them via these routings: /** * You can create this class inside the body of RootNode * * Note: You must apply the 'kotlin-parcelize' plugin to use @Parcelize * https://developer.android.com/kotlin/parcelize */ sealed class Routing : Parcelable { @Parcelize object Child1 : Routing () @Parcelize object Child2 : Routing () @Parcelize object Child3 : Routing () } Next, let's modify RootNode so it extends ParentNode : class RootNode ( buildContext : BuildContext ) : ParentNode < Routing > ( routingSource = TODO ( \"We will come back to this in Step 4\" ), buildContext = buildContext ) { ParentNode expects us to implement the abstract method resolve . This is how we relate routings to actual children. Let's use these helper methods to define some placeholders for the time being \u2013 we'll soon make them more appealing: override fun resolve ( routing : Routing , buildContext : BuildContext ): Node = when ( routing ) { Routing . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } Routing . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } Routing . Child3 -> node ( buildContext ) { Text ( text = \"Placeholder for child 3\" ) } } Great! With this mapping created, we can now just refer to children using the sealed class elements, and Appyx will be able to relate them to other nodes.","title":"3. Define children"},{"location":"how-to-use-appyx/quick-start/#4-add-a-back-stack","text":"The project wouldn't compile just yet. ParentNode expects us to pass an instance of a RoutingSource \u2013 the main control structure in any case when we want to add children. No need to worry now \u2013 for simplicity, let's just go with a simple BackStack implementation here: class RootNode ( buildContext : BuildContext , private val backStack : BackStack < Routing > = BackStack ( initialElement = Routing . Child1 , savedStateMap = buildContext . savedStateMap , ) ) : ParentNode < Routing > ( routingSource = backStack , // pass it here buildContext = buildContext ) { With this simple addition we've immediately gained a lot of power! Now we can use the back stack's API to add, replace, pop children with operations like: backStack . push ( Routing . Child2 ) // will add a new routing to the end of the stack and make it active backStack . replace ( Routing . Child3 ) // will replace the currently active child backStack . pop () // will remove the currently active child and restore the one before it Since we passed the back stack to the ParentNode , all such changes will be immediately reflected. We only need to add it to the composition: @Composable override fun View ( modifier : Modifier ) { Column { Text ( \"Hello world!\" ) // Let's add the children to the composition Children ( routingSource = backStack ) // Let's also add some controls so we can test it Row { TextButton ( onClick = { backStack . push ( Routing . Child1 ) }) { Text ( text = \"Push child 1\" ) } TextButton ( onClick = { backStack . push ( Routing . Child2 ) }) { Text ( text = \"Push child 2\" ) } TextButton ( onClick = { backStack . push ( Routing . Child3 ) }) { Text ( text = \"Push child 3\" ) } TextButton ( onClick = { backStack . pop () }) { Text ( text = \"Pop\" ) } } } }","title":"4. Add a back stack"},{"location":"how-to-use-appyx/quick-start/#5-add-transitions","text":"Adding some transitions is a one-liner: Children ( routingSource = backStack , transitionHandler = rememberBackstackSlider () ) You can also use a fader instead: rememberBackstackFader() , and you can supply a transition spec in both cases: rememberBackStackSlider { spring(stiffness = Spring.StiffnessLow) } Need something more custom? Instead of a back stack, you can find other routing sources in the library, or you can implement your own Instead of the default transition handlers, you can also use Jetpack Compose provided ones, or supply your own You can also read the Back stack documentation for more info on the specific options for the back stack.","title":"5. Add transitions"},{"location":"how-to-use-appyx/quick-start/#6-proper-child-nodes","text":"As a last step, let's replace at least one of the child placeholders with another proper node. Let's create a dedicated class: class SomeChildNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"This is SomeChildNode\" ) } } Now we can update the resolve method in RootNode so that the routing Child3 refers to this node. It should work out of the box: override fun resolve ( routing : Routing , buildContext : BuildContext ): Node = when ( routing ) { Routing . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } Routing . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } Routing . Child3 -> SomeChildNode ( buildContext ) }","title":"6. Proper child nodes"},{"location":"how-to-use-appyx/quick-start/#whats-next","text":"Congrats, you've just built your first Appyx tree! You can repeat the same pattern and make any embedded children also a ParentNode with their own children, routing sources, and transitions. As complexity grows, generally you would: Have a Node At some point make it a ParentNode and add children to it At some point extract the increasing complexity from a placeholder to another Node Repeat the same on children, go to 1. You can (and probably should) also extract local business logic, the view, any any other components into separate classes and plugins .","title":"What's next?"},{"location":"how-to-use-appyx/sample-apps/","text":"Appyx sample apps \u00b6 Where to find the sample apps \u00b6 Go to the GitHub project Fork and check out the code locally Import the project to Android Studio Showcase app \u00b6 The :app module showcases Appyx itself with multiple levels of navigation, routing source demos, etc. See it in action, then check the related code how it works. Appyx + Jetpack Compose Navigation example \u00b6 The :samples:navigation-compose module demonstrates how to use Appyx within Google's Jetpack Compose Navigation library. This example may be useful if you need to migrate to Appyx gradually. Appyx + Hilt example \u00b6 Coming soon!","title":"Sample apps"},{"location":"how-to-use-appyx/sample-apps/#appyx-sample-apps","text":"","title":"Appyx sample apps"},{"location":"how-to-use-appyx/sample-apps/#where-to-find-the-sample-apps","text":"Go to the GitHub project Fork and check out the code locally Import the project to Android Studio","title":"Where to find the sample apps"},{"location":"how-to-use-appyx/sample-apps/#showcase-app","text":"The :app module showcases Appyx itself with multiple levels of navigation, routing source demos, etc. See it in action, then check the related code how it works.","title":"Showcase app"},{"location":"how-to-use-appyx/sample-apps/#appyx-jetpack-compose-navigation-example","text":"The :samples:navigation-compose module demonstrates how to use Appyx within Google's Jetpack Compose Navigation library. This example may be useful if you need to migrate to Appyx gradually.","title":"Appyx + Jetpack Compose Navigation example"},{"location":"how-to-use-appyx/sample-apps/#appyx-hilt-example","text":"Coming soon!","title":"Appyx + Hilt example"},{"location":"other/lifecycle/","text":"Lifecycle \u00b6 Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle . Capping \u00b6 No Node can be in a higher lifecycle state than any of its parents or the Android Activity it lives in. Off-screen \u00b6 Nodes can be kept alive by their parents when removed from the view (they'll be STOPPED ) When Nodes are removed completely from their parents, they'll be DESTROYED Lifecycle changes \u00b6 The lifecycle state can be affected by: The routing source of the parent (adding or removing child Nodes ) The parent's lifecycle state capping its children (transitive in the tree) Android lifecycle (Activity) capping the whole tree Back stack node lifecycle \u00b6 An example demonstrating the above: Note that routing sources might have their slight differences (e.g. whether their operations remove a Node only from the view, or completely destroy it). In the case of the back stack: The Push operation adds a new element and stashes the currently active one \u2013 the stashed one will be removed from the view & STOPPED The Pop operation removes an element, the child Node will be DESTROYED","title":"Lifecycle"},{"location":"other/lifecycle/#lifecycle","text":"Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle .","title":"Lifecycle"},{"location":"other/lifecycle/#capping","text":"No Node can be in a higher lifecycle state than any of its parents or the Android Activity it lives in.","title":"Capping"},{"location":"other/lifecycle/#off-screen","text":"Nodes can be kept alive by their parents when removed from the view (they'll be STOPPED ) When Nodes are removed completely from their parents, they'll be DESTROYED","title":"Off-screen"},{"location":"other/lifecycle/#lifecycle-changes","text":"The lifecycle state can be affected by: The routing source of the parent (adding or removing child Nodes ) The parent's lifecycle state capping its children (transitive in the tree) Android lifecycle (Activity) capping the whole tree","title":"Lifecycle changes"},{"location":"other/lifecycle/#back-stack-node-lifecycle","text":"An example demonstrating the above: Note that routing sources might have their slight differences (e.g. whether their operations remove a Node only from the view, or completely destroy it). In the case of the back stack: The Push operation adds a new element and stashes the currently active one \u2013 the stashed one will be removed from the view & STOPPED The Pop operation removes an element, the child Node will be DESTROYED","title":"Back stack node lifecycle"},{"location":"other/plugins/","text":"Plugins \u00b6 Keeping extra concerns out of Node \u00b6 Nodes are meant to be simple structural elements, and should be kept lean. To keep the framework agnostic of any specific approach / pattern you want to use, there aren't any fixed parts. Rather, the Node offers an extension point using Plugins in its constructor: abstract class Node ( buildContext : BuildContext , val view : NodeView = EmptyNodeView , plugins : List < Plugin > = emptyList () // <-- ) So what is a Plugin ? A Plugin is an empty interface extended by many actual ones: interface Plugin Plugins \u00b6 Lifecycle-related plugins \u00b6 interface NodeLifecycleAware : Plugin { fun onCreate ( lifecycle : Lifecycle ) {} } fun interface Destroyable : Plugin { fun destroy () } Component level plugins \u00b6 Sometimes you need to grab a reference to the component as a whole, either as an interface, or its implementation, the Node . This will come especially handy when working with workflows. interface NodeAware : Plugin { val node : Node <*> fun init ( node : Node <*> ) {} } There are helper classes found in the library, so you don't have to implement the above interfaces, you can just use delegation: class SomeClass ( private val nodeAware : NodeAware = NodeAwareImpl () ) : NodeAware by nodeAware { fun foo () { // [node] is an automatically available property coming from the NodeAware interface // the reference is automatically set for you by the framework + the NodeAwareImpl class // so you can use it right away: node . doSomething () } } \u26a0\ufe0f Note: the reference to node is set by Node automatically, and isn't available immediately after constructing your object, but only after the construction of the Node itself. Navigation plugins \u00b6 In case if you need to control navigation behaviour, you can use these plugins: interface UpNavigationHandler : Plugin { fun handleUpNavigation (): Boolean = false } interface BackPressHandler : Plugin { val onBackPressedCallback : OnBackPressedCallback? get () = null } UpNavigationHandler controls Node.navigateUp behaviour and allows to intercept its invocation. BackPressHandler controls device back press behaviour via androidx.activity.OnBackPressedCallback . You can read more about it here . \u26a0\ufe0f Note: OnBackPressedCallback are invoked in the following order: 1. From children to parents. Render order of children matters! The last rendered child will be the first to handle back press. 2. Direct order of plugins within a node. Plugins are invoked in order they appears in Node(plugins = ...) before routing source. Using Plugins \u00b6 All plugins are designed to have empty {} default implementations (or other sensible defaults when a return value is defined), so it's convenient to implement them only if you need. Don't forget to pass your Plugins to your Node : internal class MyNode ( // ... plugins : List < Plugins > = emptyList () // ... ) : Node < Nothing > ( // ... plugins = plugins // ... ) \u26a0\ufe0f Note: plugins is a List , as the order matters here. All Plugin instances are invoked in the order they appear in the list.","title":"Plugins"},{"location":"other/plugins/#plugins","text":"","title":"Plugins"},{"location":"other/plugins/#keeping-extra-concerns-out-of-node","text":"Nodes are meant to be simple structural elements, and should be kept lean. To keep the framework agnostic of any specific approach / pattern you want to use, there aren't any fixed parts. Rather, the Node offers an extension point using Plugins in its constructor: abstract class Node ( buildContext : BuildContext , val view : NodeView = EmptyNodeView , plugins : List < Plugin > = emptyList () // <-- ) So what is a Plugin ? A Plugin is an empty interface extended by many actual ones: interface Plugin","title":"Keeping extra concerns out of Node"},{"location":"other/plugins/#plugins_1","text":"","title":"Plugins"},{"location":"other/plugins/#lifecycle-related-plugins","text":"interface NodeLifecycleAware : Plugin { fun onCreate ( lifecycle : Lifecycle ) {} } fun interface Destroyable : Plugin { fun destroy () }","title":"Lifecycle-related plugins"},{"location":"other/plugins/#component-level-plugins","text":"Sometimes you need to grab a reference to the component as a whole, either as an interface, or its implementation, the Node . This will come especially handy when working with workflows. interface NodeAware : Plugin { val node : Node <*> fun init ( node : Node <*> ) {} } There are helper classes found in the library, so you don't have to implement the above interfaces, you can just use delegation: class SomeClass ( private val nodeAware : NodeAware = NodeAwareImpl () ) : NodeAware by nodeAware { fun foo () { // [node] is an automatically available property coming from the NodeAware interface // the reference is automatically set for you by the framework + the NodeAwareImpl class // so you can use it right away: node . doSomething () } } \u26a0\ufe0f Note: the reference to node is set by Node automatically, and isn't available immediately after constructing your object, but only after the construction of the Node itself.","title":"Component level plugins"},{"location":"other/plugins/#navigation-plugins","text":"In case if you need to control navigation behaviour, you can use these plugins: interface UpNavigationHandler : Plugin { fun handleUpNavigation (): Boolean = false } interface BackPressHandler : Plugin { val onBackPressedCallback : OnBackPressedCallback? get () = null } UpNavigationHandler controls Node.navigateUp behaviour and allows to intercept its invocation. BackPressHandler controls device back press behaviour via androidx.activity.OnBackPressedCallback . You can read more about it here . \u26a0\ufe0f Note: OnBackPressedCallback are invoked in the following order: 1. From children to parents. Render order of children matters! The last rendered child will be the first to handle back press. 2. Direct order of plugins within a node. Plugins are invoked in order they appears in Node(plugins = ...) before routing source.","title":"Navigation plugins"},{"location":"other/plugins/#using-plugins","text":"All plugins are designed to have empty {} default implementations (or other sensible defaults when a return value is defined), so it's convenient to implement them only if you need. Don't forget to pass your Plugins to your Node : internal class MyNode ( // ... plugins : List < Plugins > = emptyList () // ... ) : Node < Nothing > ( // ... plugins = plugins // ... ) \u26a0\ufe0f Note: plugins is a List , as the order matters here. All Plugin instances are invoked in the order they appear in the list.","title":"Using Plugins"},{"location":"other/terminology/","text":"Terminology \u00b6 Node \u00b6 The main structural element of the Appyx tree. It might or might not have a view, has its own lifecycle, and can host plugins. See more in Nodes and routing . Root \u00b6 The topmost Node in the tree. Leaf Node \u00b6 A Node without any further children. Parent Node \u00b6 A Node that has other child Nodes. It has a Routing source too. Container \u00b6 A Node with children whose only responsibility is to coordinate between them. This allows both the children and the container to each keep a single responsibility. Plugin \u00b6 A generic piece of functionality that can be added into a Node . Typically you will want to implement any extra concerns, any architectural patterns, or other moving parts as plugins. See more in Plugins Routing source \u00b6 A control structure dealing with state changes of children. Back stack \u00b6 A straightforward routing source implementation: supports a linear history and a single child being active on screen. Builder \u00b6 A class to build a Node from its dependencies.","title":"Terminology"},{"location":"other/terminology/#terminology","text":"","title":"Terminology"},{"location":"other/terminology/#node","text":"The main structural element of the Appyx tree. It might or might not have a view, has its own lifecycle, and can host plugins. See more in Nodes and routing .","title":"Node"},{"location":"other/terminology/#root","text":"The topmost Node in the tree.","title":"Root"},{"location":"other/terminology/#leaf-node","text":"A Node without any further children.","title":"Leaf Node"},{"location":"other/terminology/#parent-node","text":"A Node that has other child Nodes. It has a Routing source too.","title":"Parent Node"},{"location":"other/terminology/#container","text":"A Node with children whose only responsibility is to coordinate between them. This allows both the children and the container to each keep a single responsibility.","title":"Container"},{"location":"other/terminology/#plugin","text":"A generic piece of functionality that can be added into a Node . Typically you will want to implement any extra concerns, any architectural patterns, or other moving parts as plugins. See more in Plugins","title":"Plugin"},{"location":"other/terminology/#routing-source","text":"A control structure dealing with state changes of children.","title":"Routing source"},{"location":"other/terminology/#back-stack","text":"A straightforward routing source implementation: supports a linear history and a single child being active on screen.","title":"Back stack"},{"location":"other/terminology/#builder","text":"A class to build a Node from its dependencies.","title":"Builder"},{"location":"releases/changelog/","text":"Changelog \u00b6 Pending changes \u00b6 #39 \u2013 Added: Workflows implementation to support deeplinks #47 \u2013 Updated: The 'customisations' module is now pure Java/Kotlin. #32 \u2013 Added: BackPressHandler plugin that allows to control back press behaviour via androidx.activity.OnBackPressedCallback #32 \u2013 Added: Jetpack Compose Navigation code sample 1.0-alpha03 \u00b6 #38 \u2013 Added: JUnit5 support 1.0-alpha02 \u00b6 #19 \u2013 Fixed: Do not allow setting Node.integrationPoint on non-root nodes #23 \u2013 Fixed: Integration point attached twice crash when using live literals #14 \u2013 Fixed: Transition interruptions bug #23 \u2013 Added: Unit test support #26 \u2013 Added: Publish snapshot versions #9 \u2013 Migrated app-tree-utils into this repository 1.0-alpha01 \u00b6 Initial release","title":"Changelog"},{"location":"releases/changelog/#changelog","text":"","title":"Changelog"},{"location":"releases/changelog/#pending-changes","text":"#39 \u2013 Added: Workflows implementation to support deeplinks #47 \u2013 Updated: The 'customisations' module is now pure Java/Kotlin. #32 \u2013 Added: BackPressHandler plugin that allows to control back press behaviour via androidx.activity.OnBackPressedCallback #32 \u2013 Added: Jetpack Compose Navigation code sample","title":"Pending changes"},{"location":"releases/changelog/#10-alpha03","text":"#38 \u2013 Added: JUnit5 support","title":"1.0-alpha03"},{"location":"releases/changelog/#10-alpha02","text":"#19 \u2013 Fixed: Do not allow setting Node.integrationPoint on non-root nodes #23 \u2013 Fixed: Integration point attached twice crash when using live literals #14 \u2013 Fixed: Transition interruptions bug #23 \u2013 Added: Unit test support #26 \u2013 Added: Publish snapshot versions #9 \u2013 Migrated app-tree-utils into this repository","title":"1.0-alpha02"},{"location":"releases/changelog/#10-alpha01","text":"Initial release","title":"1.0-alpha01"},{"location":"releases/downloads/","text":"Downloads \u00b6 You need to specify the following repositories in your Gradle files: repositories { mavenCentral () } Core dependencies \u00b6 dependencies { // Core implementation \"com.bumble.appyx:core:$version\" // Test rules and utility classes for testing on Android androidTestImplementation \"com.bumble.appyx:testing-ui:$version\" // Utility classes for unit testing testImplementation \"com.bumble.appyx:testing-unit-common:$version\" // Test rules and utility classes for unit testing using JUnit4 testImplementation \"com.bumble.appyx:testing-junit4:$version\" // Test extensions and utility classes for unit testing using JUnit5 testImplementation \"com.bumble.appyx:testing-junit5:$version\" } Addons \u00b6 dependencies { // Additional routing sources (such as Tiles, Promoter carousel and Modal) implementation \"com.bumble.appyx:routing-source-addons:$version\" } Interop with other libraries \u00b6 dependencies { // Optional support for RxJava 2 implementation \"com.bumble.appyx:interop-rx2:$version\" // Optional interoperability layer between Appyx and badoo/RIBs // You have to add https://jitpack.io repository to use it because badoo/RIBs is hosted there implementation \"com.bumble.appyx:interop-ribs:$version\" } Snapshot \u00b6 Snapshot version is available for all modules, use the provided repository url and main-SNAPSHOT version. repositories { maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots/' } } dependencies { implementation \"com.bumble.appyx:core:main-SNAPSHOT\" }","title":"Downloads"},{"location":"releases/downloads/#downloads","text":"You need to specify the following repositories in your Gradle files: repositories { mavenCentral () }","title":"Downloads"},{"location":"releases/downloads/#core-dependencies","text":"dependencies { // Core implementation \"com.bumble.appyx:core:$version\" // Test rules and utility classes for testing on Android androidTestImplementation \"com.bumble.appyx:testing-ui:$version\" // Utility classes for unit testing testImplementation \"com.bumble.appyx:testing-unit-common:$version\" // Test rules and utility classes for unit testing using JUnit4 testImplementation \"com.bumble.appyx:testing-junit4:$version\" // Test extensions and utility classes for unit testing using JUnit5 testImplementation \"com.bumble.appyx:testing-junit5:$version\" }","title":"Core dependencies"},{"location":"releases/downloads/#addons","text":"dependencies { // Additional routing sources (such as Tiles, Promoter carousel and Modal) implementation \"com.bumble.appyx:routing-source-addons:$version\" }","title":"Addons"},{"location":"releases/downloads/#interop-with-other-libraries","text":"dependencies { // Optional support for RxJava 2 implementation \"com.bumble.appyx:interop-rx2:$version\" // Optional interoperability layer between Appyx and badoo/RIBs // You have to add https://jitpack.io repository to use it because badoo/RIBs is hosted there implementation \"com.bumble.appyx:interop-ribs:$version\" }","title":"Interop with other libraries"},{"location":"releases/downloads/#snapshot","text":"Snapshot version is available for all modules, use the provided repository url and main-SNAPSHOT version. repositories { maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots/' } } dependencies { implementation \"com.bumble.appyx:core:main-SNAPSHOT\" }","title":"Snapshot"},{"location":"routing-sources/","text":"Routing sources \u00b6 Routing sources are the single most important abstraction of Appyx after Node . What's a routing source? \u00b6 Routing sources are controlling entities dealing with state changes of children. Their capabilities differ from implementation to implementation, however, typically: They store information on the states all children They behave like a state machine They offer some public API to trigger changing the state of children A list of routing sources \u00b6 You can take a look at some of these examples: Back stack Spotlight Tiles Promoter carousel When you feel ready, you can try to implement your own routing source . What does a routing source not do? \u00b6 The routing source represents only the model, not the looks: UI representation depends on your @Composable view hosting the children \u2013 See Adding children to the view Transition animations (if any) is a separate concern","title":"Overview"},{"location":"routing-sources/#routing-sources","text":"Routing sources are the single most important abstraction of Appyx after Node .","title":"Routing sources"},{"location":"routing-sources/#whats-a-routing-source","text":"Routing sources are controlling entities dealing with state changes of children. Their capabilities differ from implementation to implementation, however, typically: They store information on the states all children They behave like a state machine They offer some public API to trigger changing the state of children","title":"What's a routing source?"},{"location":"routing-sources/#a-list-of-routing-sources","text":"You can take a look at some of these examples: Back stack Spotlight Tiles Promoter carousel When you feel ready, you can try to implement your own routing source .","title":"A list of routing sources"},{"location":"routing-sources/#what-does-a-routing-source-not-do","text":"The routing source represents only the model, not the looks: UI representation depends on your @Composable view hosting the children \u2013 See Adding children to the view Transition animations (if any) is a separate concern","title":"What does a routing source not do?"},{"location":"routing-sources/backstack/","text":"Back stack \u00b6 Implements a simple linear history: The last element at the end of the stack is considered \"active\". All other elements are considered stashed. Children associated with stashed elements are off the screen but kept alive (see how the counter values reflect this on the video) The back stack can never be empty \u2013 it always contains at least one element. The back stack also supports different back press and operation strategies (see further down below). States \u00b6 enum class TransitionState { CREATED , ACTIVE , STASHED_IN_BACK_STACK , DESTROYED , } Constructing the back stack \u00b6 As the back stack can never be empty, it's required to define an initial routing. class BackStack < Routing : Any > ( initialElement : Routing , savedStateMap : SavedStateMap?, // Optional parameters are omitted ) Default on screen resolution \u00b6 As a default, only the active element is considered on screen. object BackStackOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { TransitionState . CREATED , TransitionState . STASHED_IN_BACK_STACK , TransitionState . DESTROYED -> false TransitionState . ACTIVE -> true } } Default transition handlers \u00b6 BackStackFader \u00b6 rememberBackstackFader() Adds simple cross-fading transitions BackStackSlider \u00b6 rememberBackstackSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen. Operations \u00b6 Push \u00b6 backStack.push(routing) Effect on stack: [A, B, C] + Push(D) = [A, B, C, D] Transitions the active element ACTIVE -> STASHED_IN_BACK_STACK . Adds a new element at the end of the stack with a CREATED -> ACTIVE transition. Replace \u00b6 backStack.replace(routing) Effect on stack: [A, B, C] + Replace(D) = [A, B, D] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Adds a new element at the end of the stack with a CREATED -> ACTIVE transition. Pop \u00b6 backStack.pop(routing) Effect on stack: [A, B, C] + Pop = [A, B] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Transitions the last stashed element STASHED_IN_BACK_STACK -> ACTIVE . Single top \u00b6 backStack.singleTop(routing) Effect on stack: depends on the contents of the stack: [A, B, C, D] + SingleTop(B) = [A, B] // of same type and equals, acts as n * Pop [A, B, C, D] + SingleTop(B') = [A, B'] // of same type but not equals, acts as n * Pop + Replace [A, B, C, D] + SingleTop(E) = [A, B, C, D, E] // not found, acts as Push Back press strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < Routing : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < Routing , TransitionState > = PopBackPressHandler (), /* ... */ ) PopBackPressHandler \u00b6 The default back press handling strategy. Runs a Pop operation. DontHandleBackPress \u00b6 Serves as a no-op. Operation strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < Routing : Any > ( /* ... */ operationStrategy : OperationStrategy < Routing , TransitionState > = ExecuteImmediately (), /* ... */ ) ExecuteImmediately \u00b6 The default strategy. New operations are executed without any questions, regardless of any already running transitions. FinishTransitionsOnNewOperation \u00b6 All running transitions are abruptly finished when a new one is started QueueOperations \u00b6 The new operation is queued and executed after the current one finishes IgnoreIfThereAreUnfinishedTransitions \u00b6 Runs the new one only if there are no transitions happening currently; ignore and discard it otherwise","title":"Back stack"},{"location":"routing-sources/backstack/#back-stack","text":"Implements a simple linear history: The last element at the end of the stack is considered \"active\". All other elements are considered stashed. Children associated with stashed elements are off the screen but kept alive (see how the counter values reflect this on the video) The back stack can never be empty \u2013 it always contains at least one element. The back stack also supports different back press and operation strategies (see further down below).","title":"Back stack"},{"location":"routing-sources/backstack/#states","text":"enum class TransitionState { CREATED , ACTIVE , STASHED_IN_BACK_STACK , DESTROYED , }","title":"States"},{"location":"routing-sources/backstack/#constructing-the-back-stack","text":"As the back stack can never be empty, it's required to define an initial routing. class BackStack < Routing : Any > ( initialElement : Routing , savedStateMap : SavedStateMap?, // Optional parameters are omitted )","title":"Constructing the back stack"},{"location":"routing-sources/backstack/#default-on-screen-resolution","text":"As a default, only the active element is considered on screen. object BackStackOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { TransitionState . CREATED , TransitionState . STASHED_IN_BACK_STACK , TransitionState . DESTROYED -> false TransitionState . ACTIVE -> true } }","title":"Default on screen resolution"},{"location":"routing-sources/backstack/#default-transition-handlers","text":"","title":"Default transition handlers"},{"location":"routing-sources/backstack/#backstackfader","text":"rememberBackstackFader() Adds simple cross-fading transitions","title":"BackStackFader"},{"location":"routing-sources/backstack/#backstackslider","text":"rememberBackstackSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen.","title":"BackStackSlider"},{"location":"routing-sources/backstack/#operations","text":"","title":"Operations"},{"location":"routing-sources/backstack/#push","text":"backStack.push(routing) Effect on stack: [A, B, C] + Push(D) = [A, B, C, D] Transitions the active element ACTIVE -> STASHED_IN_BACK_STACK . Adds a new element at the end of the stack with a CREATED -> ACTIVE transition.","title":"Push"},{"location":"routing-sources/backstack/#replace","text":"backStack.replace(routing) Effect on stack: [A, B, C] + Replace(D) = [A, B, D] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Adds a new element at the end of the stack with a CREATED -> ACTIVE transition.","title":"Replace"},{"location":"routing-sources/backstack/#pop","text":"backStack.pop(routing) Effect on stack: [A, B, C] + Pop = [A, B] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Transitions the last stashed element STASHED_IN_BACK_STACK -> ACTIVE .","title":"Pop"},{"location":"routing-sources/backstack/#single-top","text":"backStack.singleTop(routing) Effect on stack: depends on the contents of the stack: [A, B, C, D] + SingleTop(B) = [A, B] // of same type and equals, acts as n * Pop [A, B, C, D] + SingleTop(B') = [A, B'] // of same type but not equals, acts as n * Pop + Replace [A, B, C, D] + SingleTop(E) = [A, B, C, D, E] // not found, acts as Push","title":"Single top"},{"location":"routing-sources/backstack/#back-press-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < Routing : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < Routing , TransitionState > = PopBackPressHandler (), /* ... */ )","title":"Back press strategy"},{"location":"routing-sources/backstack/#popbackpresshandler","text":"The default back press handling strategy. Runs a Pop operation.","title":"PopBackPressHandler"},{"location":"routing-sources/backstack/#donthandlebackpress","text":"Serves as a no-op.","title":"DontHandleBackPress"},{"location":"routing-sources/backstack/#operation-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < Routing : Any > ( /* ... */ operationStrategy : OperationStrategy < Routing , TransitionState > = ExecuteImmediately (), /* ... */ )","title":"Operation strategy"},{"location":"routing-sources/backstack/#executeimmediately","text":"The default strategy. New operations are executed without any questions, regardless of any already running transitions.","title":"ExecuteImmediately"},{"location":"routing-sources/backstack/#finishtransitionsonnewoperation","text":"All running transitions are abruptly finished when a new one is started","title":"FinishTransitionsOnNewOperation"},{"location":"routing-sources/backstack/#queueoperations","text":"The new operation is queued and executed after the current one finishes","title":"QueueOperations"},{"location":"routing-sources/backstack/#ignoreifthereareunfinishedtransitions","text":"Runs the new one only if there are no transitions happening currently; ignore and discard it otherwise","title":"IgnoreIfThereAreUnfinishedTransitions"},{"location":"routing-sources/custom/","text":"Implementing your own routing sources \u00b6 A step-by-step guide. You can also take a look at other existing examples to see these in practice. Step 1 \u00b6 Create the class; define your possible states; define your initial state. <T> will refer to the Routing sealed class of the client code. class Foo < T : Any > ( initialItems : List < T > = listOf (), savedStateMap : SavedStateMap? ) : BaseRoutingSource < T , Foo . TransitionState > ( screenResolver = FooOnScreenResolver , // We'll see about this shortly finalState = DESTROYED , // Anything transitioning towards this state will be discarded eventually savedStateMap = savedStateMap // It's nullable if you don't need state restoration ) { // Your possible states for any single routing enum class TransitionState { CREATED , FOO , BAR , BAZ , DESTROYED ; } // You can go about it any other way. // Back stack for example defines only a single element. // Here we take all the <T> elements and make them transition CREATED -> FOO immediately. override val initialElements = initialItems . map { FooElement ( key = RoutingKey ( it ), fromState = TransitionState . CREATED , targetState = TransitionState . FOO , operation = Operation . Noop () ) } } (optional) Step 2 \u00b6 Add some convenience aliases: typealias FooElement < T > = RoutingElement < T , Foo . TransitionState > typealias FooElements < T > = RoutingElements < T , Foo . TransitionState > sealed interface FooOperation < T > : Operation < T , Foo . TransitionState > Step 3 \u00b6 Define one or more operations. @Parcelize class SomeOperation < T : Any > : FooOperation < T > { override fun isApplicable ( elements : FooElements < T > ): Boolean = TODO ( \"Define whether this operation is applicable given the current state\" ) override fun invoke ( elements : FooElements < T > , ): RoutingElements < T , Foo . TransitionState > = // TODO: Mutate elements however you please. Add, remove, change. // In this example we're changing all elements to transition to BAR. elements . map { it . transitionTo ( newTargetState = BAR , operation = this ) } } // You can add an extension method for a leaner API fun < T : Any > Foo < T > . someOperation () { accept ( FooOperation ()) } Step 4 \u00b6 Add the screen resolver to define which states should be / should not be part of the composition in the end: object FooOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { Foo . TransitionState . CREATED , Foo . TransitionState . DESTROYED -> false Foo . TransitionState . FOO , Foo . TransitionState . BAR , Foo . TransitionState . BAZ , -> true } } Step 5 \u00b6 Add one or more transition handlers to interpret different states and translate them to Jetpack Compose Modifiers . class FooTransitionHandler < T > ( private val transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ) : ModifierTransitionHandler < T , Foo . TransitionState > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . TransitionState > , descriptor : TransitionDescriptor < T , Foo . TransitionState > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . TransitionState . CREATED -> 0f Foo . TransitionState . FOO -> 0.33f Foo . TransitionState . BAR -> 0.66f Foo . TransitionState . BAZ -> 1.0f Foo . TransitionState . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < T > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ): ModifierTransitionHandler < T , Foo . TransitionState > = remember { FooTransitionHandler ( transitionSpec ) } Test it \u00b6 Add Children to your Node . Pass the routing source and the transition handler: @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier . fillMaxSize (), routingSource = foo , transitionHandler = rememberFooTransitionHandler () ) } Somewhere else in your business logic trigger the operations you defined. Make sure they're called on the same foo instance that you pass to the Children composable: foo . someOperation () As soon as this is triggered, elements should transition to the BAR state in this example, and you should see them scale up defined by the transition handler. Created something cool? \u00b6 Let us know!","title":"Writing your own"},{"location":"routing-sources/custom/#implementing-your-own-routing-sources","text":"A step-by-step guide. You can also take a look at other existing examples to see these in practice.","title":"Implementing your own routing sources"},{"location":"routing-sources/custom/#step-1","text":"Create the class; define your possible states; define your initial state. <T> will refer to the Routing sealed class of the client code. class Foo < T : Any > ( initialItems : List < T > = listOf (), savedStateMap : SavedStateMap? ) : BaseRoutingSource < T , Foo . TransitionState > ( screenResolver = FooOnScreenResolver , // We'll see about this shortly finalState = DESTROYED , // Anything transitioning towards this state will be discarded eventually savedStateMap = savedStateMap // It's nullable if you don't need state restoration ) { // Your possible states for any single routing enum class TransitionState { CREATED , FOO , BAR , BAZ , DESTROYED ; } // You can go about it any other way. // Back stack for example defines only a single element. // Here we take all the <T> elements and make them transition CREATED -> FOO immediately. override val initialElements = initialItems . map { FooElement ( key = RoutingKey ( it ), fromState = TransitionState . CREATED , targetState = TransitionState . FOO , operation = Operation . Noop () ) } }","title":"Step 1"},{"location":"routing-sources/custom/#optional-step-2","text":"Add some convenience aliases: typealias FooElement < T > = RoutingElement < T , Foo . TransitionState > typealias FooElements < T > = RoutingElements < T , Foo . TransitionState > sealed interface FooOperation < T > : Operation < T , Foo . TransitionState >","title":"(optional) Step 2"},{"location":"routing-sources/custom/#step-3","text":"Define one or more operations. @Parcelize class SomeOperation < T : Any > : FooOperation < T > { override fun isApplicable ( elements : FooElements < T > ): Boolean = TODO ( \"Define whether this operation is applicable given the current state\" ) override fun invoke ( elements : FooElements < T > , ): RoutingElements < T , Foo . TransitionState > = // TODO: Mutate elements however you please. Add, remove, change. // In this example we're changing all elements to transition to BAR. elements . map { it . transitionTo ( newTargetState = BAR , operation = this ) } } // You can add an extension method for a leaner API fun < T : Any > Foo < T > . someOperation () { accept ( FooOperation ()) }","title":"Step 3"},{"location":"routing-sources/custom/#step-4","text":"Add the screen resolver to define which states should be / should not be part of the composition in the end: object FooOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { Foo . TransitionState . CREATED , Foo . TransitionState . DESTROYED -> false Foo . TransitionState . FOO , Foo . TransitionState . BAR , Foo . TransitionState . BAZ , -> true } }","title":"Step 4"},{"location":"routing-sources/custom/#step-5","text":"Add one or more transition handlers to interpret different states and translate them to Jetpack Compose Modifiers . class FooTransitionHandler < T > ( private val transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ) : ModifierTransitionHandler < T , Foo . TransitionState > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . TransitionState > , descriptor : TransitionDescriptor < T , Foo . TransitionState > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . TransitionState . CREATED -> 0f Foo . TransitionState . FOO -> 0.33f Foo . TransitionState . BAR -> 0.66f Foo . TransitionState . BAZ -> 1.0f Foo . TransitionState . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < T > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ): ModifierTransitionHandler < T , Foo . TransitionState > = remember { FooTransitionHandler ( transitionSpec ) }","title":"Step 5"},{"location":"routing-sources/custom/#test-it","text":"Add Children to your Node . Pass the routing source and the transition handler: @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier . fillMaxSize (), routingSource = foo , transitionHandler = rememberFooTransitionHandler () ) } Somewhere else in your business logic trigger the operations you defined. Make sure they're called on the same foo instance that you pass to the Children composable: foo . someOperation () As soon as this is triggered, elements should transition to the BAR state in this example, and you should see them scale up defined by the transition handler.","title":"Test it"},{"location":"routing-sources/custom/#created-something-cool","text":"Let us know!","title":"Created something cool?"},{"location":"routing-sources/promoter/","text":"Promoter carousel \u00b6 Intended only as an illustration. States \u00b6 enum class TransitionState { CREATED , STAGE1 , STAGE2 , STAGE3 , STAGE4 , SELECTED , DESTROYED } Default on screen resolution \u00b6 internal object PromoterOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { TransitionState . DESTROYED -> false else -> true } } Default transition handler \u00b6 As elements are promoted to next stages, they're: animated on a circular path scaled up rotated in the selection / discard stages You can check PromoterTransitionHandler for implementation details. Operations \u00b6 Add first \u00b6 promoter.addFirst(routing) Adds a new element at the start of the element list with a CREATED state. Promote all \u00b6 promoter.promoteAll(routing) All elements are transitioned to the next state: CREATED -> STAGE1 STAGE1 -> STAGE2 STAGE2 -> STAGE3 STAGE3 -> STAGE4 STAGE4 -> SELECTED SELECTED -> DESTROYED","title":"Promoter"},{"location":"routing-sources/promoter/#promoter-carousel","text":"Intended only as an illustration.","title":"Promoter carousel"},{"location":"routing-sources/promoter/#states","text":"enum class TransitionState { CREATED , STAGE1 , STAGE2 , STAGE3 , STAGE4 , SELECTED , DESTROYED }","title":"States"},{"location":"routing-sources/promoter/#default-on-screen-resolution","text":"internal object PromoterOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { TransitionState . DESTROYED -> false else -> true } }","title":"Default on screen resolution"},{"location":"routing-sources/promoter/#default-transition-handler","text":"As elements are promoted to next stages, they're: animated on a circular path scaled up rotated in the selection / discard stages You can check PromoterTransitionHandler for implementation details.","title":"Default transition handler"},{"location":"routing-sources/promoter/#operations","text":"","title":"Operations"},{"location":"routing-sources/promoter/#add-first","text":"promoter.addFirst(routing) Adds a new element at the start of the element list with a CREATED state.","title":"Add first"},{"location":"routing-sources/promoter/#promote-all","text":"promoter.promoteAll(routing) All elements are transitioned to the next state: CREATED -> STAGE1 STAGE1 -> STAGE2 STAGE2 -> STAGE3 STAGE3 -> STAGE4 STAGE4 -> SELECTED SELECTED -> DESTROYED","title":"Promote all"},{"location":"routing-sources/spotlight/","text":"Spotlight \u00b6 Implements a mechanism analogous to a view pager; has a single active element (\"it's in the spotlight\", hence the name), but unlike the back stack, it does not remove other elements. It's great for flows or tabbed containers. States \u00b6 enum class TransitionState { INACTIVE_BEFORE , ACTIVE , INACTIVE_AFTER ; } Constructing spotlight \u00b6 Requires defining items and an active index. class Spotlight < Routing : Any > ( items : List < Routing > , initialActiveIndex : Int = 0 , savedStateMap : SavedStateMap?, // Optional parameters are omitted ) Default on screen resolution \u00b6 As a default, only the active element is considered on screen. object SpotlightOnScreenResolver : OnScreenStateResolver < Spotlight . TransitionState > { override fun isOnScreen ( state : Spotlight . TransitionState ): Boolean = when ( state ) { Spotlight . TransitionState . INACTIVE_BEFORE , Spotlight . TransitionState . INACTIVE_AFTER -> false Spotlight . TransitionState . ACTIVE -> true } } Default transition handlers \u00b6 SpotlightFader \u00b6 rememberSpotlightFader() Adds simple cross-fading transitions SpotlightSlider \u00b6 rememberSpotlightSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen, depending on the order of them in the items property. Operations \u00b6 Activate \u00b6 spotlight.activate(routing) Transitions the element to ACTIVE . Transitions other elements to INACTIVE_BEFORE or INACTIVE_AFTER depending on their relative position to the activated element. Next \u00b6 spotlight.next() Transitions the currently active element to INACTIVE_BEFORE . Transitions the element after the currently active one to ACTIVE . Previous \u00b6 spotlight.previous() Transitions the currently active element to INACTIVE_AFTER . Transitions the element before the currently active one to ACTIVE . Update elements \u00b6 spotlight.updateElements(items, activeIndex) Replaces elements held by the spotlight instance with a new list. Transitions new elements to INACTIVE_BEFORE , ACTIVE , or INACTIVE_AFTER depending on their position in the provided list relative to activeIndex . Back press strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < Routing : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < Routing , TransitionState > = GoToDefault ( initialActiveIndex ) /* ... */ ) GoToDefault \u00b6 The default back press handling strategy. Activates the default index. GoToPrevious \u00b6 Runs a Previous operation. Operation strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < Routing : Any > ( /* ... */ operationStrategy : OperationStrategy < Routing , TransitionState > = ExecuteImmediately (), /* ... */ ) ExecuteImmediately \u00b6 The default strategy. New operations are executed without any questions, regardless of any already running transitions.","title":"Spotlight"},{"location":"routing-sources/spotlight/#spotlight","text":"Implements a mechanism analogous to a view pager; has a single active element (\"it's in the spotlight\", hence the name), but unlike the back stack, it does not remove other elements. It's great for flows or tabbed containers.","title":"Spotlight"},{"location":"routing-sources/spotlight/#states","text":"enum class TransitionState { INACTIVE_BEFORE , ACTIVE , INACTIVE_AFTER ; }","title":"States"},{"location":"routing-sources/spotlight/#constructing-spotlight","text":"Requires defining items and an active index. class Spotlight < Routing : Any > ( items : List < Routing > , initialActiveIndex : Int = 0 , savedStateMap : SavedStateMap?, // Optional parameters are omitted )","title":"Constructing spotlight"},{"location":"routing-sources/spotlight/#default-on-screen-resolution","text":"As a default, only the active element is considered on screen. object SpotlightOnScreenResolver : OnScreenStateResolver < Spotlight . TransitionState > { override fun isOnScreen ( state : Spotlight . TransitionState ): Boolean = when ( state ) { Spotlight . TransitionState . INACTIVE_BEFORE , Spotlight . TransitionState . INACTIVE_AFTER -> false Spotlight . TransitionState . ACTIVE -> true } }","title":"Default on screen resolution"},{"location":"routing-sources/spotlight/#default-transition-handlers","text":"","title":"Default transition handlers"},{"location":"routing-sources/spotlight/#spotlightfader","text":"rememberSpotlightFader() Adds simple cross-fading transitions","title":"SpotlightFader"},{"location":"routing-sources/spotlight/#spotlightslider","text":"rememberSpotlightSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen, depending on the order of them in the items property.","title":"SpotlightSlider"},{"location":"routing-sources/spotlight/#operations","text":"","title":"Operations"},{"location":"routing-sources/spotlight/#activate","text":"spotlight.activate(routing) Transitions the element to ACTIVE . Transitions other elements to INACTIVE_BEFORE or INACTIVE_AFTER depending on their relative position to the activated element.","title":"Activate"},{"location":"routing-sources/spotlight/#next","text":"spotlight.next() Transitions the currently active element to INACTIVE_BEFORE . Transitions the element after the currently active one to ACTIVE .","title":"Next"},{"location":"routing-sources/spotlight/#previous","text":"spotlight.previous() Transitions the currently active element to INACTIVE_AFTER . Transitions the element before the currently active one to ACTIVE .","title":"Previous"},{"location":"routing-sources/spotlight/#update-elements","text":"spotlight.updateElements(items, activeIndex) Replaces elements held by the spotlight instance with a new list. Transitions new elements to INACTIVE_BEFORE , ACTIVE , or INACTIVE_AFTER depending on their position in the provided list relative to activeIndex .","title":"Update elements"},{"location":"routing-sources/spotlight/#back-press-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < Routing : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < Routing , TransitionState > = GoToDefault ( initialActiveIndex ) /* ... */ )","title":"Back press strategy"},{"location":"routing-sources/spotlight/#gotodefault","text":"The default back press handling strategy. Activates the default index.","title":"GoToDefault"},{"location":"routing-sources/spotlight/#gotoprevious","text":"Runs a Previous operation.","title":"GoToPrevious"},{"location":"routing-sources/spotlight/#operation-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < Routing : Any > ( /* ... */ operationStrategy : OperationStrategy < Routing , TransitionState > = ExecuteImmediately (), /* ... */ )","title":"Operation strategy"},{"location":"routing-sources/spotlight/#executeimmediately","text":"The default strategy. New operations are executed without any questions, regardless of any already running transitions.","title":"ExecuteImmediately"},{"location":"routing-sources/tiles/","text":"Tiles \u00b6 Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful. States \u00b6 enum class TransitionState { CREATED , STANDARD , SELECTED , DESTROYED } Default on screen resolution \u00b6 internal object TilesOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { TransitionState . CREATED , TransitionState . STANDARD , TransitionState . SELECTED -> true TransitionState . DESTROYED -> false } } Default transition handler \u00b6 Selection translates to scaling. Destroying makes elements fly off the screen with rotation and downscaling. Operations \u00b6 Add \u00b6 tiles.add(routing) Adds a new element to the routing source immediately transitioning from CREATED -> STANDARD . Destroy \u00b6 tiles.destroy(routing) Transitions a given element to DESTROYED . Select \u00b6 tiles.select(routing) Transitions a given element STANDARD -> SELECTED . Deselect \u00b6 tiles.deselect(routing) Transitions a given element SELECTED -> STANDARD . Deselect all \u00b6 tiles.deselectAll() Transitions all elements SELECTED -> STANDARD . Remove selected \u00b6 tiles.removeSelected() Transitions all elements that have SELECTED state to DESTROYED .","title":"Tiles"},{"location":"routing-sources/tiles/#tiles","text":"Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful.","title":"Tiles"},{"location":"routing-sources/tiles/#states","text":"enum class TransitionState { CREATED , STANDARD , SELECTED , DESTROYED }","title":"States"},{"location":"routing-sources/tiles/#default-on-screen-resolution","text":"internal object TilesOnScreenResolver : OnScreenStateResolver < TransitionState > { override fun isOnScreen ( state : TransitionState ): Boolean = when ( state ) { TransitionState . CREATED , TransitionState . STANDARD , TransitionState . SELECTED -> true TransitionState . DESTROYED -> false } }","title":"Default on screen resolution"},{"location":"routing-sources/tiles/#default-transition-handler","text":"Selection translates to scaling. Destroying makes elements fly off the screen with rotation and downscaling.","title":"Default transition handler"},{"location":"routing-sources/tiles/#operations","text":"","title":"Operations"},{"location":"routing-sources/tiles/#add","text":"tiles.add(routing) Adds a new element to the routing source immediately transitioning from CREATED -> STANDARD .","title":"Add"},{"location":"routing-sources/tiles/#destroy","text":"tiles.destroy(routing) Transitions a given element to DESTROYED .","title":"Destroy"},{"location":"routing-sources/tiles/#select","text":"tiles.select(routing) Transitions a given element STANDARD -> SELECTED .","title":"Select"},{"location":"routing-sources/tiles/#deselect","text":"tiles.deselect(routing) Transitions a given element SELECTED -> STANDARD .","title":"Deselect"},{"location":"routing-sources/tiles/#deselect-all","text":"tiles.deselectAll() Transitions all elements SELECTED -> STANDARD .","title":"Deselect all"},{"location":"routing-sources/tiles/#remove-selected","text":"tiles.removeSelected() Transitions all elements that have SELECTED state to DESTROYED .","title":"Remove selected"},{"location":"ui/children-view/","text":"Adding children to the view \u00b6 Routing sources define the model of dealing with children. This section describes different ways of adding them to the composition. All the below mentioned composables should be added to the View of the parent node. Children \u00b6 Renders all visible children of a routing source. This is the simplest and most common case. @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier , // optional routingSource = TODO (), transitionHandler = TODO () // optional ) } Child \u00b6 Renders a single child associated to a RoutingElement . Useful if you want to define different child placements in the layout individually. @Composable override fun View ( modifier : Modifier ) { Child ( routingElement = element , transitionHandler = TODO () ) { child , _ -> // TODO wrap in your own composables child () } } Lazy lists / grids \u00b6 @Composable override fun View ( modifier : Modifier ) { // TODO grab all visible children from the routing source manually val children by routingSource . visibleChildrenAsState () GridExample ( children ) } @Composable private fun GridExample ( elements : List < RoutingElement < Routing , out Any? >> ) { LazyVerticalGrid ( columns = Fixed ( 2 ), modifier = Modifier . fillMaxSize (), contentPadding = PaddingValues ( horizontal = 16. dp ), ) { items ( elements ) { element -> // TODO use Child composable to render them individually inside the list / grid Child ( routingElement = element ) } } }","title":"Children"},{"location":"ui/children-view/#adding-children-to-the-view","text":"Routing sources define the model of dealing with children. This section describes different ways of adding them to the composition. All the below mentioned composables should be added to the View of the parent node.","title":"Adding children to the view"},{"location":"ui/children-view/#children","text":"Renders all visible children of a routing source. This is the simplest and most common case. @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier , // optional routingSource = TODO (), transitionHandler = TODO () // optional ) }","title":"Children"},{"location":"ui/children-view/#child","text":"Renders a single child associated to a RoutingElement . Useful if you want to define different child placements in the layout individually. @Composable override fun View ( modifier : Modifier ) { Child ( routingElement = element , transitionHandler = TODO () ) { child , _ -> // TODO wrap in your own composables child () } }","title":"Child"},{"location":"ui/children-view/#lazy-lists-grids","text":"@Composable override fun View ( modifier : Modifier ) { // TODO grab all visible children from the routing source manually val children by routingSource . visibleChildrenAsState () GridExample ( children ) } @Composable private fun GridExample ( elements : List < RoutingElement < Routing , out Any? >> ) { LazyVerticalGrid ( columns = Fixed ( 2 ), modifier = Modifier . fillMaxSize (), contentPadding = PaddingValues ( horizontal = 16. dp ), ) { items ( elements ) { element -> // TODO use Child composable to render them individually inside the list / grid Child ( routingElement = element ) } } }","title":"Lazy lists / grids"},{"location":"ui/transitions/","text":"Transitions \u00b6 No transitions \u00b6 Using the provided Child-related composables you'll see no transitions as a default \u2013 routing changes will happen instantly. Jetpack Compose default animations \u00b6 You can use standard Compose animations for embedded child Nodes in the view, e.g. AnimatedVisibility : var visibility by remember { mutableStateOf ( true ) } Child ( routingElement ) { child , _ -> AnimatedVisibility ( visible = visibility ) { child () } } Appyx transition handlers \u00b6 All the child composables provided by Appyx accept an optional transitionHandler argument too: You can use the provided ones as they're a one-liner to add \u2013 you can check the individual Routing sources for the ones they come shipped with. You can also implement your own. The benefit of using transition handlers is you can represent any custom state of elements defined by your routing source with Compose Modifiers . The example below is taken from custom routing sources . It matches custom transition states to different scaling values, and returns a scale Modifier . class FooTransitionHandler < T > ( private val transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ) : ModifierTransitionHandler < T , Foo . TransitionState > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . TransitionState > , descriptor : TransitionDescriptor < T , Foo . TransitionState > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . TransitionState . CREATED -> 0f Foo . TransitionState . FOO -> 0.33f Foo . TransitionState . BAR -> 0.66f Foo . TransitionState . BAZ -> 1.0f Foo . TransitionState . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < T > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ): ModifierTransitionHandler < T , Foo . TransitionState > = remember { FooTransitionHandler ( transitionSpec ) } You can find more complex examples in the implementations of other routing sources, such as the Promoter carousel","title":"Transitions"},{"location":"ui/transitions/#transitions","text":"","title":"Transitions"},{"location":"ui/transitions/#no-transitions","text":"Using the provided Child-related composables you'll see no transitions as a default \u2013 routing changes will happen instantly.","title":"No transitions"},{"location":"ui/transitions/#jetpack-compose-default-animations","text":"You can use standard Compose animations for embedded child Nodes in the view, e.g. AnimatedVisibility : var visibility by remember { mutableStateOf ( true ) } Child ( routingElement ) { child , _ -> AnimatedVisibility ( visible = visibility ) { child () } }","title":"Jetpack Compose default animations"},{"location":"ui/transitions/#appyx-transition-handlers","text":"All the child composables provided by Appyx accept an optional transitionHandler argument too: You can use the provided ones as they're a one-liner to add \u2013 you can check the individual Routing sources for the ones they come shipped with. You can also implement your own. The benefit of using transition handlers is you can represent any custom state of elements defined by your routing source with Compose Modifiers . The example below is taken from custom routing sources . It matches custom transition states to different scaling values, and returns a scale Modifier . class FooTransitionHandler < T > ( private val transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ) : ModifierTransitionHandler < T , Foo . TransitionState > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . TransitionState > , descriptor : TransitionDescriptor < T , Foo . TransitionState > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . TransitionState . CREATED -> 0f Foo . TransitionState . FOO -> 0.33f Foo . TransitionState . BAR -> 0.66f Foo . TransitionState . BAZ -> 1.0f Foo . TransitionState . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < T > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . TransitionState , Float > = { spring () } ): ModifierTransitionHandler < T , Foo . TransitionState > = remember { FooTransitionHandler ( transitionSpec ) } You can find more complex examples in the implementations of other routing sources, such as the Promoter carousel","title":"Appyx transition handlers"}]}